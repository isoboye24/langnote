generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Group {
  id        String @id @default(uuid()) @db.Uuid
  groupName String
  userId    String @db.Uuid
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  Word      Word[]
}

model PartOfSpeech {
  id              String            @id @default(uuid()) @db.Uuid
  name            String
  languageId      String            @db.Uuid
  Language        Language          @relation(fields: [languageId], references: [id])
  PopularListWord PopularListWord[]
  Word            Word[]
}

model Language {
  id                  String                @id @default(uuid()) @db.Uuid
  languageName        String
  Gender              Gender[]
  PartOfSpeech        PartOfSpeech[]
  PopularListCategory PopularListCategory[]
  PopularListWord     PopularListWord[]
  User                User[]
  WordCase            WordCase[]
}

model PopularListCategory {
  id              String            @id @default(uuid()) @db.Uuid
  popularCategory String
  languageId      String            @db.Uuid
  darkImageIcon   String
  lightImageIcon  String
  Language        Language          @relation(fields: [languageId], references: [id])
  PopularListWord PopularListWord[]

  @@index([languageId])
}

model PopularListWord {
  id                String              @id @default(uuid()) @db.Uuid
  word              String
  known             Boolean
  favorite          Boolean
  wordCaseId        String              @db.Uuid
  partOfSpeechId    String              @db.Uuid
  createdAt         DateTime            @default(now()) @db.Timestamp(6)
  updatedAt         DateTime            @updatedAt @db.Timestamp(6)
  synonym           String?
  antonym           String?
  meaning           String?
  popularCategoryId String              @db.Uuid
  languageId        String              @db.Uuid
  genderId          String              @db.Uuid
  gender            Gender              @relation(fields: [genderId], references: [id])
  Language          Language            @relation(fields: [languageId], references: [id])
  partOfSpeech      PartOfSpeech        @relation(fields: [partOfSpeechId], references: [id], onDelete: Cascade)
  popularCategory   PopularListCategory @relation(fields: [popularCategoryId], references: [id], onDelete: Cascade)
  wordCase          WordCase            @relation(fields: [wordCaseId], references: [id], onDelete: Cascade)

  @@index([partOfSpeechId])
  @@index([wordCaseId])
  @@index([popularCategoryId])
  @@index([languageId])
}

model WordCase {
  id              String            @id @default(uuid()) @db.Uuid
  languageId      String            @db.Uuid
  caseName        String
  PopularListWord PopularListWord[]
  Word            Word[]
  Language        Language          @relation(fields: [languageId], references: [id])

  @@index([languageId])
}

model Gender {
  id              String            @id @default(uuid()) @db.Uuid
  languageId      String            @db.Uuid
  genderName      String
  Language        Language          @relation(fields: [languageId], references: [id])
  PopularListWord PopularListWord[]
  Word            Word[]

  @@index([languageId])
}

model User {
  id            String    @id @default(uuid()) @db.Uuid
  userName      String    @unique(map: "user_userName_idx")
  firstName     String    @default("NO_NAME")
  lastName      String    @default("NO_NAME")
  email         String    @default("NO_Email")
  emailVerified DateTime? @db.Timestamp(6)
  password      String
  role          Role      @default(user)
  createdAt     DateTime  @default(now()) @db.Timestamp(6)
  languageId    String    @db.Uuid
  Group         Group[]
  Review        Review[]
  sessions      Session[]
  language      Language  @relation(fields: [languageId], references: [id], onDelete: Cascade)
  Word          Word[]

  @@index([languageId])
}

model Session {
  sessionToken String   @id
  userId       String   @db.Uuid
  expires      DateTime @db.Timestamp(6)
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Word {
  id             String       @id @default(uuid()) @db.Uuid
  word           String
  known          Boolean
  favorite       Boolean
  groupId        String       @db.Uuid
  userId         String       @db.Uuid
  wordCaseId     String       @db.Uuid
  partOfSpeechId String       @db.Uuid
  createdAt      DateTime     @default(now()) @db.Timestamp(6)
  updatedAt      DateTime     @updatedAt @db.Timestamp(6)
  synonym        String?
  antonym        String?
  meaning        String?
  genderId       String       @db.Uuid
  gender         Gender       @relation(fields: [genderId], references: [id])
  group          Group        @relation(fields: [groupId], references: [id], onDelete: Cascade)
  partOfSpeech   PartOfSpeech @relation(fields: [partOfSpeechId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  wordCase       WordCase     @relation(fields: [wordCaseId], references: [id], onDelete: Cascade)

  @@unique([userId, word])
  @@index([userId])
  @@index([groupId])
  @@index([partOfSpeechId])
  @@index([wordCaseId])
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
}

model Review {
  id         String   @id @db.Uuid
  reviewText String
  userId     String   @db.Uuid
  createdAt  DateTime @default(now()) @db.Timestamp(6)
  updatedAt  DateTime @updatedAt @db.Timestamp(6)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

enum Role {
  user
  admin
}
